FILE package.json
{
  "name": "foititiki-olistiki",
  "version": "1.0.0",
  "type": "module",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "docx": "^9.0.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "nodemailer": "^6.9.14"
  }
}

FILE .env.example
PORT=3000
TO_EMAIL=dchionis10@gmail.com

SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=YOUR_GMAIL_ADDRESS
SMTP_PASS=YOUR_GMAIL_APP_PASSWORD
SMTP_FROM=YOUR_GMAIL_ADDRESS

FILE server.js
import express from "express";
import nodemailer from "nodemailer";
import dotenv from "dotenv";
import { Document, Packer, Paragraph, TextRun, HeadingLevel } from "docx";

dotenv.config();

const app = express();
app.use(express.json({ limit: "1mb" }));

const PORT = Number(process.env.PORT || 3000);
const TO_EMAIL = process.env.TO_EMAIL || "dchionis10@gmail.com";

function htmlPage() {
  return `<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Φοιτητική Ολιστική Συμπεριφορική Παρέμβαση</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 24px; max-width: 980px; }
    h1 { margin: 0 0 8px 0; }
    h2 { margin: 0 0 10px 0; }
    .lead { margin: 0 0 18px 0; line-height: 1.35; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 16px; margin: 12px 0; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .field { flex: 1; min-width: 220px; }
    label { display: block; font-size: 14px; margin: 6px 0; }
    input[type="text"], input[type="email"], textarea {
      width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px;
    }
    textarea { min-height: 90px; }
    .item { padding: 10px; border-top: 1px solid #eee; }
    .item:first-child { border-top: 0; }
    .scale { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    .scale label { display: inline-flex; align-items: center; gap: 6px; margin: 0; }
    .muted { color: #555; font-size: 13px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px; }
    button { padding: 12px 16px; border: 0; border-radius: 10px; cursor: pointer; }
    #submitBtn { background: #111; color: #fff; }
    #previewBtn { background: #f1f1f1; }
    #status { margin-top: 10px; font-size: 14px; }
    .results { background: #fafafa; border-radius: 10px; padding: 12px; border: 1px solid #eee; }
    .warn { color: #8a2a2a; }
    .ok { color: #1f6f3a; }
  </style>
</head>

<body>
  <h1>Φοιτητική Ολιστική Συμπεριφορική Παρέμβαση</h1>

  <p class="lead">
    Αυτό είναι screening και πρακτικό προφίλ.  
    Σου δίνει τρεις δείκτες που επηρεάζουν μελέτη, συνέπεια, και ανάκαμψη.  
    Σου δίνει προτεραιότητες και ένα πρώτο πλάνο βελτίωσης.
  </p>

  <div class="card">
    <h2>Στοιχεία</h2>
    <div class="row">
      <div class="field">
        <label>Ονοματεπώνυμο</label>
        <input id="name" type="text" placeholder="π.χ. Μαρία Παπαδοπούλου" />
      </div>
      <div class="field">
        <label>Email</label>
        <input id="email" type="email" placeholder="π.χ. maria@email.com" />
      </div>
      <div class="field">
        <label>Σχολή ή Τμήμα</label>
        <input id="school" type="text" placeholder="π.χ. Ψυχολογία" />
      </div>
      <div class="field">
        <label>Έτος φοίτησης</label>
        <input id="year" type="text" placeholder="π.χ. 2ο" />
      </div>
    </div>

    <label>Στόχος για τις επόμενες 4 εβδομάδες</label>
    <textarea id="goal" placeholder="π.χ. να διαβάζω 4 ημέρες την εβδομάδα με σταθερό πρόγραμμα"></textarea>

    <label>Σημειώσεις</label>
    <textarea id="notes" placeholder="π.χ. τι σε δυσκολεύει πιο πολύ"></textarea>

    <label style="margin-top:10px;">
      <input id="consent" type="checkbox" />
      Συμφωνώ να σταλεί αναφορά στον Δρ Χιώνη και κατανοώ ότι αυτό δεν είναι ιατρική διάγνωση.
    </label>

    <p class="muted">
      Αν υπάρχει άμεσος κίνδυνος ή έντονη κρίση, ζήτησε άμεση βοήθεια από επείγουσες υπηρεσίες.
    </p>
  </div>

  <div class="card">
    <h2>Κλίμακα 1. Ρύθμιση Συναισθήματος για Μελέτη</h2>
    <p class="muted">Κλίμακα 1 έως 5. 1 σημαίνει καθόλου. 5 σημαίνει πάρα πολύ.</p>
    <div id="erItems"></div>
  </div>

  <div class="card">
    <h2>Κλίμακα 2. Κοινωνική Στήριξη και Ανήκειν</h2>
    <p class="muted">Κλίμακα 1 έως 5. 1 σημαίνει καθόλου. 5 σημαίνει πάρα πολύ.</p>
    <div id="ssItems"></div>
  </div>

  <div class="card">
    <h2>Κλίμακα 3. Ανθεκτικότητα και Επανεκκίνηση</h2>
    <p class="muted">Κλίμακα 1 έως 5. 1 σημαίνει καθόλου. 5 σημαίνει πάρα πολύ.</p>
    <div id="rrItems"></div>
  </div>

  <div class="card">
    <h2>Αποτελέσματα</h2>
    <div class="results" id="resultsBox">Πάτα Προεπισκόπηση για να δεις σκορ.</div>

    <div class="actions">
      <button id="previewBtn" type="button">Προεπισκόπηση σκορ</button>
      <button id="submitBtn" type="button">Υποβολή και αποστολή αναφοράς</button>
    </div>

    <div id="status"></div>
  </div>

<script>
  const scales = {
    er: {
      title: "Ρύθμιση Συναισθήματος για Μελέτη",
      min: 1, max: 5,
      items: [
        "Όταν πιέζομαι, μπορώ να ηρεμήσω αρκετά ώστε να ξεκινήσω μελέτη.",
        "Μπορώ να αλλάξω την οπτική μου όταν ένα διάβασμα μου φαίνεται βουνό.",
        "Όταν αγχώνομαι, κάνω κάτι μικρό που με επαναφέρει σε 10 λεπτά.",
        "Μπορώ να συνεχίσω μελέτη ακόμη και αν δεν έχω διάθεση.",
        "Όταν κάνω λάθος ή κολλήσω, δεν καταρρέω ψυχολογικά.",
        "Μπορώ να μιλήσω στον εαυτό μου με ήρεμο τρόπο όταν αποτυγχάνω.",
        "Μπορώ να βάλω όριο σε σκέψεις που με τραβάνε σε υπερανάλυση.",
        "Μπορώ να ζητήσω βοήθεια αντί να κλειστώ όταν πιέζομαι."
      ]
    },
    ss: {
      title: "Κοινωνική Στήριξη και Ανήκειν",
      min: 1, max: 5,
      items: [
        "Υπάρχει τουλάχιστον ένα άτομο που μπορώ να μιλήσω χωρίς φόβο κριτικής.",
        "Νιώθω ότι ανήκω σε μία μικρή ομάδα ανθρώπων που με στηρίζει.",
        "Όταν δυσκολεύομαι, μπορώ να ζητήσω πρακτική βοήθεια και να την πάρω.",
        "Όταν δυσκολεύομαι, μπορώ να ζητήσω συναισθηματική στήριξη και να την πάρω.",
        "Έχω ένα άτομο που με ενθαρρύνει με συγκεκριμένο τρόπο για τη σχολή.",
        "Δεν νιώθω μόνη όταν έχω πίεση από εξετάσεις.",
        "Μπορώ να βάλω όρια σε σχέσεις που με εξαντλούν.",
        "Μπορώ να μιλήσω για άγχος ή ντροπή χωρίς να νιώσω ότι εκτίθεμαι."
      ]
    },
    rr: {
      title: "Ανθεκτικότητα και Επανεκκίνηση",
      min: 1, max: 5,
      items: [
        "Μετά από μία κακή μέρα, μπορώ να ξαναμπώ στο πρόγραμμα την επόμενη.",
        "Όταν χάνω ρυθμό, μπορώ να κάνω επανεκκίνηση με μικρό βήμα.",
        "Μπορώ να κρατήσω μία ρουτίνα ύπνου που στηρίζει τη μελέτη.",
        "Μπορώ να κάνω μικρές σταθερές προσπάθειες χωρίς υπερπροσπάθεια.",
        "Αν αποτύχω σε στόχο, μπορώ να το δω σαν δεδομένο και όχι σαν ταυτότητα.",
        "Μπορώ να προστατεύσω ενέργεια και συγκέντρωση από περισπασμούς.",
        "Όταν κουράζομαι, αναγνωρίζω το όριο και κάνω σωστή ανάκαμψη.",
        "Συνήθως βρίσκω τρόπο να συνεχίσω ακόμη και όταν υπάρχουν εμπόδια."
      ]
    }
  };

  function escapeHtml(s) {
    return String(s || "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderScale(containerId, key) {
    const sc = scales[key];
    const root = document.getElementById(containerId);
    root.innerHTML = "";

    sc.items.forEach(function(txt, idx) {
      const itemNo = idx + 1;
      const wrap = document.createElement("div");
      wrap.className = "item";

      const title = document.createElement("div");
      title.innerHTML = "<strong>" + itemNo + ".</strong> " + escapeHtml(txt);

      const scale = document.createElement("div");
      scale.className = "scale";

      for (let v = sc.min; v <= sc.max; v++) {
        const lab = document.createElement("label");
        lab.innerHTML = '<input type="radio" name="' + key + "_" + itemNo + '" value="' + v + '" /> <span>' + v + "</span>";
        scale.appendChild(lab);
      }

      wrap.appendChild(title);
      wrap.appendChild(scale);
      root.appendChild(wrap);
    });
  }

  function readAnswers(key) {
    const sc = scales[key];
    const answers = [];
    for (let i = 1; i <= sc.items.length; i++) {
      const sel = document.querySelector('input[name="' + key + "_" + i + '"]:checked');
      if (!sel) return null;
      answers.push(Number(sel.value));
    }
    return answers;
  }

  function mean(arr) {
    return arr.reduce(function(a,b){ return a + b; }, 0) / arr.length;
  }

  function band(score) {
    if (score < 2.6) return { label: "Χαμηλό", cls: "warn" };
    if (score < 3.6) return { label: "Μέτριο", cls: "" };
    return { label: "Υψηλό", cls: "ok" };
  }

  function buildPreviewHtml() {
    const er = readAnswers("er");
    const ss = readAnswers("ss");
    const rr = readAnswers("rr");
    if (!er || !ss || !rr) return "Συμπλήρωσε όλες τις απαντήσεις για να δεις σκορ.";

    const erM = mean(er);
    const ssM = mean(ss);
    const rrM = mean(rr);
    const overall = mean([erM, ssM, rrM]);

    const erB = band(erM);
    const ssB = band(ssM);
    const rrB = band(rrM);
    const ovB = band(overall);

    let html = "";
    html += "<div><strong>Σύνολο</strong></div>";
    html += "<div>Γενικό σκορ " + overall.toFixed(2) + ". <span class='" + ovB.cls + "'>" + ovB.label + "</span></div>";
    html += "<br/>";
    html += "<div><strong>Ανά κλίμακα</strong></div>";
    html += "<div>Ρύθμιση συναισθήματος " + erM.toFixed(2) + ". <span class='" + erB.cls + "'>" + erB.label + "</span></div>";
    html += "<div>Κοινωνική στήριξη " + ssM.toFixed(2) + ". <span class='" + ssB.cls + "'>" + ssB.label + "</span></div>";
    html += "<div>Ανθεκτικότητα " + rrM.toFixed(2) + ". <span class='" + rrB.cls + "'>" + rrB.label + "</span></div>";
    html += "<br/>";
    html += "<div class='muted'>Το αποτέλεσμα είναι screening και όχι διάγνωση.</div>";
    return html;
  }

  document.getElementById("previewBtn").addEventListener("click", function() {
    document.getElementById("resultsBox").innerHTML = buildPreviewHtml();
  });

  document.getElementById("submitBtn").addEventListener("click", async function() {
    const statusEl = document.getElementById("status");
    statusEl.textContent = "";

    const name = document.getElementById("name").value.trim();
    const email = document.getElementById("email").value.trim();
    const school = document.getElementById("school").value.trim();
    const year = document.getElementById("year").value.trim();
    const goal = document.getElementById("goal").value.trim();
    const notes = document.getElementById("notes").value.trim();
    const consent = document.getElementById("consent").checked;

    if (!name || !email) {
      statusEl.textContent = "Συμπλήρωσε ονοματεπώνυμο και email.";
      return;
    }
    if (!consent) {
      statusEl.textContent = "Χρειάζεται συγκατάθεση για αποστολή αναφοράς.";
      return;
    }

    const er = readAnswers("er");
    const ss = readAnswers("ss");
    const rr = readAnswers("rr");
    if (!er || !ss || !rr) {
      statusEl.textContent = "Συμπλήρωσε όλες τις απαντήσεις πριν την υποβολή.";
      return;
    }

    const btn = document.getElementById("submitBtn");
    btn.disabled = true;
    statusEl.textContent = "Γίνεται αποστολή αναφοράς.";

    try {
      const payload = { meta: { name, email, school, year, goal, notes }, answers: { er, ss, rr } };
      const res = await fetch("/api/submit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        const t = await res.text();
        throw new Error(t || "Σφάλμα υποβολής.");
      }

      alert("Ευχαριστούμε για την υποβολή. Επικοινωνείστε με τον Δρ Χιώνη παρακαλούμε.");
      statusEl.textContent = "Ολοκληρώθηκε.";
    } catch (e) {
      statusEl.textContent = "Αποτυχία αποστολής. Δοκίμασε ξανά.";
    } finally {
      btn.disabled = false;
    }
  });

  renderScale("erItems", "er");
  renderScale("ssItems", "ss");
  renderScale("rrItems", "rr");
</script>
</body>
</html>`;
}

app.get("/", (req, res) => {
  res.type("html").send(htmlPage());
});

function mean(arr) {
  return arr.reduce((a, b) => a + b, 0) / arr.length;
}

function band(score) {
  if (score < 2.6) return "Χαμηλό";
  if (score < 3.6) return "Μέτριο";
  return "Υψηλό";
}

function practicalMeaning(scaleKey, score) {
  const b = band(score);

  if (scaleKey === "er") {
    if (b === "Χαμηλό") return [
      "Υπάρχει αυξημένη πιθανότητα μπλοκαρίσματος στην έναρξη μελέτης όταν υπάρχει άγχος.",
      "Υπάρχει αυξημένη πιθανότητα αποφυγής ή υπερανάλυσης όταν ένα task φαίνεται δύσκολο."
    ];
    if (b === "Μέτριο") return [
      "Υπάρχει λειτουργία αλλά σε ημέρες πίεσης πέφτει η συνέπεια.",
      "Βοηθά ένα μικρό πρωτόκολλο επανεκκίνησης πριν από κάθε μπλοκ μελέτης."
    ];
    return [
      "Υπάρχει καλή ρύθμιση και η απόδοση εξαρτάται πιο πολύ από σύστημα και ρουτίνα.",
      "Βοηθά βελτιστοποίηση κανόνων περιβάλλοντος και σαφών μικρών στόχων."
    ];
  }

  if (scaleKey === "ss") {
    if (b === "Χαμηλό") return [
      "Υπάρχει κίνδυνος να σηκώνει όλο το φορτίο μόνη της και να φθείρεται σιωπηλά.",
      "Βοηθά να στηθούν δύο σταθερές επαφές και σαφή όρια σε εξαντλητικές σχέσεις."
    ];
    if (b === "Μέτριο") return [
      "Υπάρχει στήριξη αλλά δεν ενεργοποιείται έγκαιρα όταν ανεβαίνει η πίεση.",
      "Βοηθά πλάνο επικοινωνίας με μικρά αιτήματα και σαφή χρονισμό."
    ];
    return [
      "Υπάρχει λειτουργική στήριξη και μειώνεται το ρίσκο απομόνωσης σε εξεταστικές περιόδους.",
      "Βοηθά να γίνει η στήριξη πιο πρακτική με ρόλους και συμφωνίες."
    ];
  }

  if (scaleKey === "rr") {
    if (b === "Χαμηλό") return [
      "Υπάρχει αυξημένη πιθανότητα να χαλάει ο ρυθμός μετά από setback και να αργεί η επανεκκίνηση.",
      "Βοηθά σταθεροποίηση ύπνου και μικρά βήματα επανόδου με χαμηλή τριβή."
    ];
    if (b === "Μέτριο") return [
      "Υπάρχει επανεκκίνηση αλλά δεν είναι σταθερή όταν συσσωρεύεται κόπωση.",
      "Βοηθά διαχείριση ενέργειας και κανόνες για περισπασμούς."
    ];
    return [
      "Υπάρχει καλή επανεκκίνηση και η πρόοδος εξαρτάται από monitoring και στόχους.",
      "Βοηθά εβδομαδιαίο review με δείκτες και SMART στόχους."
    ];
  }

  return ["", ""];
}

function followUpPlan(erScore, ssScore, rrScore) {
  const lows = [erScore, ssScore, rrScore].filter(s => band(s) === "Χαμηλό").length;
  const mids = [erScore, ssScore, rrScore].filter(s => band(s) === "Μέτριο").length;

  if (lows >= 2) {
    return {
      sessions: 8,
      frequency: "1 φορά την εβδομάδα",
      goals: [
        "SMART 1. 4 ημέρες μελέτη την εβδομάδα, 4 μπλοκ των 25 λεπτών ανά ημέρα, για 4 εβδομάδες.",
        "SMART 2. Σταθερό ωράριο ύπνου, απόκλιση έως 45 λεπτά, για 14 ημέρες.",
        "SMART 3. 2 στοχευμένες επαφές στήριξης την εβδομάδα με σαφές αίτημα."
      ]
    };
  }

  if (lows === 1 || mids >= 2) {
    return {
      sessions: 6,
      frequency: "1 φορά την εβδομάδα",
      goals: [
        "SMART 1. 3 ημέρες μελέτη την εβδομάδα, 4 μπλοκ των 25 λεπτών, για 3 εβδομάδες.",
        "SMART 2. Τελετουργικό έναρξης 2 λεπτών πριν από κάθε μπλοκ, για 14 ημέρες.",
        "SMART 3. Πλάνο ανάκαμψης 20 λεπτών, σε 4 βράδια την εβδομάδα, για 3 εβδομάδες."
      ]
    };
  }

  return {
    sessions: 4,
    frequency: "1 φορά ανά 2 εβδομάδες",
    goals: [
      "SMART 1. Εβδομαδιαίο review 15 λεπτών με 3 δείκτες, για 8 εβδομάδες.",
      "SMART 2. Κανόνας κινητού σε ώρες μελέτης, με ένα διάλειμμα ανά 25λεπτο, για 14 ημέρες.",
      "SMART 3. Στόχος σταθερότητας και όχι έντασης, με μικρές βελτιώσεις, για 4 εβδομάδες."
    ]
  };
}

function mappingNarrativeParagraphs() {
  return [
    new Paragraph({ children: [new TextRun({ text: "Τι μετράμε και με τι αντιστοιχεί", bold: true })] }),
    new Paragraph("Αυτή η αξιολόγηση είναι screening και όχι ιατρική διάγνωση."),
    new Paragraph("Στόχος είναι να παραχθεί πρακτικό προφίλ για μελέτη και καθημερινότητα."),
    new Paragraph("Στόχος είναι να οδηγήσει σε SMART πλάνο και σε follow up, αν χρειάζεται."),

    new Paragraph("Άξονας 1. Ρύθμιση και αντιμετώπιση πίεσης."),
    new Paragraph("Μετράμε πώς ξεκινά η μελέτη όταν υπάρχει στρες."),
    new Paragraph("Μετράμε πώς αλλάζει η οπτική όταν κάτι φαίνεται βουνό."),
    new Paragraph("Η θεματική αντιστοιχεί εννοιολογικά σε coping και επαναξιολόγηση."),

    new Paragraph("Άξονας 2. Κοινωνική στήριξη και ανήκειν."),
    new Paragraph("Μετράμε πόσο εύκολα ενεργοποιείται στήριξη όταν υπάρχει πίεση."),
    new Paragraph("Μετράμε πόσο ασφαλές είναι να μιλήσει χωρίς φόβο κριτικής."),
    new Paragraph("Η θεματική αντιστοιχεί εννοιολογικά σε απομόνωση, μοναξιά, και μοτίβα δεσμού."),

    new Paragraph("Άξονας 3. Ανάκαμψη και λειτουργική σταθερότητα."),
    new Paragraph("Μετράμε πόσο γρήγορα γίνεται επανεκκίνηση μετά από setback."),
    new Paragraph("Μετράμε πόσο σταθερές είναι ρουτίνες που στηρίζουν ύπνο και συγκέντρωση."),
    new Paragraph("Η θεματική αντιστοιχεί εννοιολογικά σε ανάκαμψη, ύπνο, και λειτουργικότητα."),

    new Paragraph("Πώς δένει με SARIM."),
    new Paragraph("Ο άξονας 1 αφορά εκτίμηση πίεσης και άμεση αντίδραση."),
    new Paragraph("Ο άξονας 2 αφορά πόρους και κανάλια στήριξης."),
    new Paragraph("Ο άξονας 3 αφορά ανάκαμψη και feedback loop μέσα στην εβδομάδα."),

    new Paragraph("Σημείωση για την αντιστοίχιση."),
    new Paragraph("Οι αντιστοιχίες είναι εννοιολογικές και δεν είναι ισοδυναμία τεστ."),
    new Paragraph("Τα items είναι πρωτότυπα και είναι φτιαγμένα για εφαρμογή σε φοιτητικό πλαίσιο.")
  ];
}

async function makeDocx(meta, scores) {
  const { erScore, ssScore, rrScore, overall } = scores;

  const erMeaning = practicalMeaning("er", erScore);
  const ssMeaning = practicalMeaning("ss", ssScore);
  const rrMeaning = practicalMeaning("rr", rrScore);

  const plan = followUpPlan(erScore, ssScore, rrScore);

  const doc = new Document({
    sections: [{
      children: [
        new Paragraph({ text: "Αναφορά Screening Φοιτητικής Ολιστικής Συμπεριφορικής Παρέμβασης", heading: HeadingLevel.HEADING_1 }),

        new Paragraph({ children: [new TextRun({ text: "Σκοπός αξιολόγησης", bold: true })] }),
        new Paragraph("Η αξιολόγηση στοχεύει σε πρακτικό screening για μελέτη, ανθεκτικότητα και στήριξη."),
        new Paragraph("Το αποτέλεσμα δεν αποτελεί ιατρική διάγνωση και δεν αντικαθιστά κλινική εκτίμηση."),

        new Paragraph({ children: [new TextRun({ text: "Στοιχεία", bold: true })] }),
        new Paragraph(`Ονοματεπώνυμο: ${meta.name || ""}`),
        new Paragraph(`Email: ${meta.email || ""}`),
        new Paragraph(`Σχολή ή Τμήμα: ${meta.school || ""}`),
        new Paragraph(`Έτος: ${meta.year || ""}`),
        new Paragraph(`Στόχος 4 εβδομάδων: ${meta.goal || ""}`),
        new Paragraph(`Σημειώσεις: ${meta.notes || ""}`),

        new Paragraph(""),
        ...mappingNarrativeParagraphs(),
        new Paragraph(""),

        new Paragraph({ children: [new TextRun({ text: "Αποτελέσματα", bold: true })] }),
        new Paragraph(`Γενικό σκορ: ${overall.toFixed(2)}. Επίπεδο: ${band(overall)}`),
        new Paragraph(`Ρύθμιση συναισθήματος: ${erScore.toFixed(2)}. Επίπεδο: ${band(erScore)}`),
        new Paragraph(`Κοινωνική στήριξη: ${ssScore.toFixed(2)}. Επίπεδο: ${band(ssScore)}`),
        new Paragraph(`Ανθεκτικότητα: ${rrScore.toFixed(2)}. Επίπεδο: ${band(rrScore)}`),

        new Paragraph(""),
        new Paragraph({ children: [new TextRun({ text: "Τι σημαίνουν πρακτικά", bold: true })] }),

        new Paragraph("Ρύθμιση συναισθήματος"),
        new Paragraph(`1. ${erMeaning[0]}`),
        new Paragraph(`2. ${erMeaning[1]}`),

        new Paragraph(""),
        new Paragraph("Κοινωνική στήριξη"),
        new Paragraph(`1. ${ssMeaning[0]}`),
        new Paragraph(`2. ${ssMeaning[1]}`),

        new Paragraph(""),
        new Paragraph("Ανθεκτικότητα"),
        new Paragraph(`1. ${rrMeaning[0]}`),
        new Paragraph(`2. ${rrMeaning[1]}`),

        new Paragraph(""),
        new Paragraph({ children: [new TextRun({ text: "Πρόταση follow up", bold: true })] }),
        new Paragraph(`Προτεινόμενες συνεδρίες: ${plan.sessions}`),
        new Paragraph(`Συχνότητα: ${plan.frequency}`),
        new Paragraph("Στοχοθεσία SMART"),
        ...plan.goals.map(g => new Paragraph(g)),

        new Paragraph(""),
        new Paragraph({ children: [new TextRun({ text: "Σημείωση ασφάλειας", bold: true })] }),
        new Paragraph("Αν υπάρχουν ενδείξεις σοβαρής επιβάρυνσης ή κινδύνου, προτείνεται άμεση κλινική εκτίμηση.")
      ]
    }]
  });

  return Packer.toBuffer(doc);
}

async function sendEmailWithAttachment(buffer, meta) {
  const host = process.env.SMTP_HOST;
  const port = Number(process.env.SMTP_PORT || 587);
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;
  const from = process.env.SMTP_FROM || user;

  if (!host || !user || !pass) {
    throw new Error("Missing SMTP settings.");
  }

  const transporter = nodemailer.createTransport({
    host,
    port,
    secure: false,
    auth: { user, pass }
  });

  const safeName = String(meta.name || "report")
    .replace(/[^\p{L}\p{N}\s]/gu, "")
    .trim()
    .slice(0, 60) || "report";

  const filename = `Αναφορά_${safeName}.docx`;

  await transporter.sendMail({
    from,
    to: TO_EMAIL,
    subject: "Νέα αναφορά Φοιτητικής Ολιστικής Συμπεριφορικής Παρέμβασης",
    text: `Στάλθηκε αναφορά για ${meta.name || ""}. Email συμμετέχοντα: ${meta.email || ""}.`,
    attachments: [{ filename, content: buffer }]
  });
}

app.post("/api/submit", async (req, res) => {
  try {
    const meta = req.body?.meta || {};
    const answers = req.body?.answers || {};

    if (!meta.name || !meta.email) return res.status(400).send("Λείπουν βασικά στοιχεία.");
    if (!Array.isArray(answers.er) || !Array.isArray(answers.ss) || !Array.isArray(answers.rr)) return res.status(400).send("Λείπουν απαντήσεις.");

    if (answers.er.length !== 8 || answers.ss.length !== 8 || answers.rr.length !== 8) return res.status(400).send("Λάθος πλήθος απαντήσεων.");

    const erScore = mean(answers.er.map(Number));
    const ssScore = mean(answers.ss.map(Number));
    const rrScore = mean(answers.rr.map(Number));
    const overall = mean([erScore, ssScore, rrScore]);

    const buffer = await makeDocx(meta, { erScore, ssScore, rrScore, overall });
    await sendEmailWithAttachment(buffer, meta);

    return res.status(200).send("OK");
  } catch (e) {
    return res.status(500).send("Server error");
  }
});

app.listen(PORT, () => {
  console.log("Running at http://localhost:" + PORT);
});

END
